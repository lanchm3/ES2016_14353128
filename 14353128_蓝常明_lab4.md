## Lab4 死锁
### 实验目的
理解死锁概念和分析死锁产生条件
### 死锁停留截图：

![](https://github.com/lanchm3/ES2016_14353128/blob/master/Deadlock.png)

### 产生死锁的四个必要条件
1. 互斥条件：一个资源每次只能被一个进程使用
2. 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放
3. 不剥夺条件：进程已获得的资源，在未使用完之前，不能强行剥夺
4. 循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系
### 产生死锁的原因
在Deadlock的构造函数，定义了一个新的A类变量a和另一个新的B类变量b。当线程t启动被调用时，它会在后台调用run函数去使用a，b的资源。与此同时，t还会经过等待之后会执行a.methd(b)使用a，b的资源。由于synchronized的作用，使得一个对象的一部分synchronized资源只能允许被一个线程访问。但是如果这时有其他线程访问该对象的这部分synchronized资源或者其他部分synchronized资源，都会被阻塞，所以当run函数用b.method(a)方法使b取访问a的资源数据时，t已经占用了a资源，而run函数又占用了t函数要用到的b资源，所以就造成了阻塞，两个函数都在等待资源，这就造成了死锁。